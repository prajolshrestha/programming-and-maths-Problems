#include <tbb/parallel_for.h>

#include <algorithm>
#include <vector>
#include <random>
#include <iterator> 
#include <chrono>

// Compile: g++ 1_dynamic.cpp -o 1_dynamic -O3 -ltbb
// check time: time ./1_dynamic

int main() {

    // Create a random number generator 
    std::random_device rd;
    std::mt19937 mt(rd()); // seed

    // Create 1 distribution
    std::uniform_int_distribution bin(20, 30);

    // Calculate the number elements per bin
    int num_work_items = 1 << 18;

    // Create work items
    std::vector<int> work_items; //create a int vector
    // Syntax: Fill a range with values generated by a given function (append generated value to the end of vector, number of elements to generate,
    //                                                          lambda expression)
    std::generate_n(std::back_inserter(work_items), num_work_items, 
                [&] {return bin(mt); }); // generate "num_work_items" random numbers using lambda expression and insert random numbers into the vector
    
    // Process all elements in the "work_items" vector using a parallel_for loop
    // Syntax: parallelizing loop(define a loop range, lambda expression, partitioner)
    tbb::parallel_for(
        tbb::blocked_range<int>(0, num_work_items),
        [&](tbb::blocked_range<int> r) {
            for (int i= r.begin(); i<r.end(); i++) {
                std::this_thread::sleep_for(std::chrono::microseconds(work_items[i])); // each thread sleeps for microseconds [this sleep simulates some computational workload on each work item]
            }
        });

    return 0;
}

// Conclusion: static and dynamic both works at similar time for even job length.